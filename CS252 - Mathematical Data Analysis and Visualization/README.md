This README file is intented to outline what each project is about. The projects below are listed in chronological order these projects were completed.

---

**Project 1: Data Analysis and Visualization**  
[Project 1 Instructions](https://cs.colby.edu/courses/S21/cs251/projects/p1datavis/p1datavis252.html)

For this project, the objective of this project was to introduce to student the python package numpy, to create some functions to compute generic statistical data, and to use to the python package matplotlib to create some data visualization. I was tasked to implement the Data object, an object that reads a dataset and extract all features of that dataset. Then, we use that object to create an Anaylsis class. This class computes statistical data on the dataset. Lastly, I used matplotlib to visualize the results from the two previous objects.

**Project 2: Matrix Transformations**  
[Project 2 Instructions](https://cs.colby.edu/courses/S21/cs251/projects/p2mattrans/p2mattrans252.html)

The goal of this project is to create a Transformation class that creates a general-purpose translation, rotation, and scaling matrix. At the end of the project, I used these matrices to manipulate data to either match plots provided in the project or match a description of what the data should look like. The final task of the project is to use the different matrices above to examine 3-dimensional data.

**Project 3: Linear Regression**  
[Project 3 Instructions](https://cs.colby.edu/courses/S21/cs251/projects/p3linearregression/p3linearregression252.html)

The objective of this project to create algorithms to perform a linear regression. I was tasked to create these algorithms using SciPy built-in least square solver, using known facts about normal equations, and using QR matrix decomposition. The project concludes by comparing the different advantages and disadvantages of each algorithm.

**Project 4: PCA and Eigenfaces**  
[Project 4 Instructions](https://cs.colby.edu/courses/S21/cs251/projects/p4pca/p4pca252.html)

This project is about developing algorithms to perform principal component anaylsis or PCA. I applied these algorithms to the Iris dataset and a celebrity face images dataset. Therefore, I create a function that maps our data into PCA space. Then, I would create another that would project a proper subset of the PCA data back into the data space. Lastly, I would use the two datasets mentioned above to anaylze the performance of the PCA algorithm.

**Project 5: Clustering and Image Segmentation**  
[Project 5 Instructions](https://cs.colby.edu/courses/S21/cs251/projects/p5clustering/p5clustering252.html)

This project focuses on implementing a K-means cluster algorithm and applying it on a set of images. Thus, I would create an class called KMeans that would take in a dataset and perform the K-means algorithm. It would also store important information about the dataset and contain functions that visualize the results of the clustering algorithm. Then, I would use this class to perform the algorithm on a set of images and observe the results of the algorithm.

**Project 6: Email Spam Classification**  
[Project 6 Instructions](https://cs.colby.edu/courses/S21/cs251/projects/p6spam/p6spam252.html)

The goal of this project is to learn and implement the K Nearest Neighbors and Naive Bayes algorithm. I used these algorithms individually to determine whether an email is or is not spam from the Enron email dataset. At the end of the project, I compared the results of the two algorithms. Therefore, in the project, I created a classes that implements one of the two algorithms above. In those classes, I created other methods that would either visualize the results of the algorithm, retreive useful information about the dataset, or compute some statistical quantity from the dataset.

**Project 7: Neural Networks and Handwriting Recognition**  
[Project 7 Instructions](https://cs.colby.edu/courses/S21/cs251/projects/p7neuralnets/p7neuralnets252.html)

In this project, the goal to create a Radial Basis Function neutral network to recognize hand-written digits. Therefore, I learned how these neutral networks and implemented the different layers needed to implement this neutral network. Lastly, I used my implementation of this neutral network to automate the process of recognizing handwritten digits.
